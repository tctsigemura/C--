% 
% 付録：コマンドリファレンス
%
\chapter{コマンドリファレンス}
\label{app:command}

%UNIX や MacOS 上で動作する{\cmm}コンパイラの使用方法を解説します．

\section{{\cme}コマンド}

{\cmm}プログラムを{\tac}で実行できる{\tt .exe}ファイルに変換します．
{\cme}コマンドは，内部で「\ref{command:cmmc} {\cmmc}コマンド」や
「{\tt Util--}ユーティリティ」プログラムを自動的に呼び出すシェルスクリプトです．

\begin{flushleft}
\begin{tabular}{l l}
{\bf 形式 : } & \|cm2e [-h] [-o exec] [-s ###] [-S] [-c] [-E] [-K] [-P] | \\
              & ~~~ \| [-nostdinc] [-I <dir>] [-c] [-Dxx=yy] <file>...|
\end{tabular}
\end{flushleft}

{\tt <file>...}の各ファイルについて，
プリプロセッサ({\tt cpp})，
コンパイラ({\tt c--})，
アセンブラ({\tt as--})を順に呼び出し，
リロケータブルオブジェクト(「{\tt Util--}解説書」参照)に変換します．
次に，
リンカー({\tt ld--})を用いリロケータブルオブジェクトを結合します．
最後に，実行可能形式作成プログラム({\tt objexe--})を呼び出し
{\tt .exe}ファイルを作成します．

{\cme}は，
指定されたファイルの拡張子からファイルの種類を判断し，
必要な処理を自動的に実行します．
拡張子「{\tt .cmm}」は{\cmml}のソースプログラム，
「{\tt .s}」は{\tac}のアセンブリ言語プログラム，
「{\tt .o}」は{\tac}のリロケータブルオブジェクトと判断します．

\begin{quote}
\hspace{-1em}以下のオプションが使用できます．

\begin{description}
\item[{\tt -h}] : 使用方法メッセージを表示します．
\item[{\tt -o}] : 作成する{\tt .exe}ファイルの名前を指定します．
{\tt -o}オプションの後ろに空白で区切ってファイル名を入力します．
\item[{\tt -s}] : プログラムのスタック領域サイズをバイト単位で明示します．
  {\tt -s}オプションの後ろに空白で区切ってサイズを10進数で入力します．
  スタックサイズを明示しない場合は，規定値の600が使用されます．
\item[{\tt -S}] : アセンブラソースプログラム{\tt .s}の作成まで行い，
  それより後の処理を行いません．
\item[{\tt -c}] : リロケータブルオブジェクトファイル{\tt .o}の作成まで行い，
  それより後の処理を行いません．
\item[{\tt -E}] : プリプロセッサで処理した{.cmm}ファイルの内容を
  標準出力ストリームに書き出します．
\item[{\tt -K}] : {\tacos}カーネル用モードでコンパイルを行います．
  コンパイル結果に，
  ユーザプログラム用のスタックオーバーフローチェック機能を埋め込みません．
\item[{\tt -P}] : I/O特権モードの{\tt .exe}ファイルを作ります．
  {\tacos}のI/O特権モードユーザプログラムは，
  \|IN|，\|OUT|機械語命令を実行することができます．
\item[{\tt -nostdinc}] : 標準のインクルードディレクトリを使用しません．
\item[{\tt -I}] : インクルードディレクトリを追加します．
このオプションを繰り返し使用しすることで複数のディレクトリを追加できます．
\item[{\tt -D}] : このオプションは，そのままプリプロセッサに渡されます．
次に使用例を示します．\\
\|$ cm2e -DDEBUG=1 -o hello hello.cmm|
\end{description}
\end{quote}

\section{{\cmc}コマンド}

{\cmm}プログラムを{\cl}プログラムに変換した後，
{\cl}プログラムをコンパイルしてUNIXやmacOSの実行形式を作成します．
{\cmc}コマンドは，必要なプログラムを自動的に呼び出すシェルスクリプトです．

\begin{flushleft}
\begin{tabular}{l l}
{\bf 形式 : } & \|cm2c [-h] [-o exec] [-S] [-c] [-E] [-nostdinc] [-rtc] | \\
              & ~~~ \| [-nortc] [-I <dir>] [-Dxx=yy] <file>...|
\end{tabular}
\end{flushleft}

{\tt <file>...}の各ファイルについて，
プリプロセッサ({\tt cpp})，
トランスレータ({\tt c-c--}または{\tt rtc-c--}），
{\tt C}コンパイラドライバ({\tt cc})を順に呼び出し，
UNIXやmacOSのリロケータブルオブジェクトに変換します．
次に，{\tt C}コンパイラドライバ({\tt cc})を呼び出し，
リロケータブルオブジェクトを結合し実行可能ファイルを作成します．

{\cmc}は，
指定されたファイルの拡張子からファイルの種類を判断し，
必要な処理を自動的に実行します．
拡張子「{\tt .cmm}」は{\cmml}のソースプログラム，
「{\tt .c}」は{\cl}ソースプログラム，
「{\tt .o}」はUNIXやMacのリロケータブルオブジェクトと判断します．

\begin{quote}
\hspace{-1em}以下のオプションが使用できます．

\begin{description}
\item[{\tt -h}] : 使用方法メッセージを表示します．
\item[{\tt -o}] : 作成する実行可能ファイルの名前を指定します．
{\tt -o}オプションの後ろに空白で区切ってファイル名を入力します．
\item[{\tt -S}] : {\cl}ソースプログラム{\tt .c}の作成まで行い，
  それより後の処理を行いません．
\item[{\tt -c}] : リロケータブルオブジェクトファイル{\tt .o}の作成まで行い，
  それより後の処理を行いません．
\item[{\tt -E}] : プリプロセッサで処理した{.cmm}ファイルの内容を
  標準出力ストリームに書き出します．
\item[{\tt -nostdinc}] : 標準のインクルードディレクトリを使用しません．
\item[{\tt -rtc}] : 実行時エラーチェックを行う実行形式を作成します．
  実行時エラーチェックの内容は，\|null|参照の使用と配列の添字範囲チェックです．
  実行時エラーチェックは実験的な実装です．
  現在のところ\|malloc|を用いた配列領域の確保と互換性がありません．
\item[{\tt -nortc}] : 実行時エラーチェックを行わない実行形式を作成します．
  デフォルトが{\tt -nortc}です．
\item[{\tt -I}] : インクルードディレクトリを追加します．
  このオプションを繰り返し使用しすることで複数のディレクトリを追加できます．
\item[{\tt -D}] : このオプションは，そのままプリプロセッサに渡されます．
\end{description}
\end{quote}

\section{{\cmi}コマンド}

{\cmm}プログラムをコンパイルして中間言語に変換します．
{\cmi}コマンドは，
内部で「\ref{command:vcmmc} {\icmmc}コマンド」を呼び出すシェルスクリプトです．

\begin{flushleft}
{\bf 形式 : }~~~\|cm2i [-h] [-E] [-nostdinc] [-I <dir>] [-Dxx=yy] <file>...|
\end{flushleft}

{\tt <file>...}の各ファイルについて，
プリプロセッサ({\tt cpp})，
コンパイラ({\tt ic-c--})
を順に呼び出し中間言語({\tt .i})を出力します．
{\cmi}コマンドに指定できるファイルは，
拡張子「{\tt .cmm}」の{\cmml}ソースプログラムだけです．

\begin{quote}
\hspace{-1em}以下のオプションが使用できます．

\begin{description}
\item[{\tt -h}] : 使用方法メッセージを表示します．
\item[{\tt -E}] : プリプロセッサで処理した{.cmm}ファイルの内容を
標準出力ストリームに書き出します．
それより後の処理を行いません．
\item[{\tt -nostdinc}] : 標準のインクルードディレクトリを使用しません．
\item[{\tt -I}] : インクルードディレクトリを追加します．
このオプションを繰り返し使用しすることで複数のディレクトリを追加できます．
\item[{\tt -D}] : このオプションは，そのままプリプロセッサに渡されます．
\end{description}
\end{quote}

\section{{\cmv}コマンド}

{\cmm}プログラムをコンパイルして仮想スタックマシンのニーモニックに変換します．
{\cmv}コマンドは，
内部で「\ref{command:vcmmc} {\vcmmc}コマンド」を呼び出すシェルスクリプトです．

\begin{flushleft}
{\bf 形式 : }~~~\|cm2v [-h] [-E] [-nostdinc] [-I <dir>] [-Dxx=yy] <file>...|
\end{flushleft}

{\tt <file>...}の各ファイルについて，
プリプロセッサ({\tt cpp})，
コンパイラ({\tt vm-c--})
を順に呼び出し仮想スタックマシンのニーモニック({\tt .v})を出力します．
{\cmv}コマンドに指定できるファイルは，
拡張子「{\tt .cmm}」の{\cmml}ソースプログラムだけです．

\begin{quote}
\hspace{-1em}以下のオプションが使用できます．

\begin{description}
\item[{\tt -h}] : 使用方法メッセージを表示します．
\item[{\tt -E}] : プリプロセッサで処理した{.cmm}ファイルの内容を
標準出力ストリームに書き出します．
それより後の処理を行いません．
\item[{\tt -nostdinc}] : 標準のインクルードディレクトリを使用しません．
\item[{\tt -I}] : インクルードディレクトリを追加します．
このオプションを繰り返し使用しすることで複数のディレクトリを追加できます．
\item[{\tt -D}] : このオプションは，そのままプリプロセッサに渡されます．
\end{description}
\end{quote}

\section{{\cmmc}コマンド}
\label{command:cmmc}

{\cmml}の{\tac}用コンパイラです．
{\bf 通常は{\cme}から起動されユーザが直接使用することはありません．}
\cmml で記述されたプログラムを入力し，
\tac アセンブリ言語で記述したプログラムに変換します．
\cmmc コマンドの書式は次の通りです．

\begin{flushleft}
{\bf 形式 : }~~~\|c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]|\\
({\bf 注意}：オプションは書式の順番で指定する必要があります．)
\end{flushleft}

引数に \cmml のソースプログラムファイルを指定した場合は，
指定されたファイルからソースプログラムを読み込みます．
ファイルが省略された場合は標準入力ストリームからソースプログラムを読み込みます．
どちらの場合もコンパイル結果は標準出力ストリームに出力します．
ソースプログラムファイルの拡張子は「\|.cmm|」にします．

\|-h|，\|-v|オプションは使用法メッセージを表示します．
\|-O0|オプションを指定すると，
ソースコード中の定数式をコンパイル時に計算したり，
実行されることがないプログラムの部分を削除したりする等の最適化をしません．
\|-O|，\|-O1|は最適化を促すオプションですが，
デフォルトで\|ON|になっているので指定する必要はありません．
\|-K|オプションを使うと，
関数入口へのスタックオーバーフロー検出コードの埋め込みが抑制されます．
\tacos のカーネルをコンパイルするときに使用するオプションです．

\section{{\ccmmc}コマンド}
\label{command:ccmmc}

{\cmm}プログラムを{\cl}に変換して出力するトランスレータです．
{\bf 通常は{\cmc}から起動されユーザが直接使用することはありません．}

\begin{flushleft}
{\bf 形式 : }~~~\|c-c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]|\\
({\bf 注意}：オプションは書式の順番で指定する必要があります．)
\end{flushleft}

引数の意味は{\cmmc}コマンドと同様です．

\section{{\rtccmmc}コマンド}
\label{command:rtccmmc}

{\cmm}プログラムを{\cl}に変換して出力するトランスレータです．
{\bf 通常は{\cmc}から起動されユーザが直接使用することはありません．}
{\rtccmmc}は{\ccmmc}と異なり，
ユーザプログラムが\|null|参照を使用したり，
範囲外の添字を用いて配列をアクセスしていないか
チェックするコードを出力に埋め込みます．

現在のところ実行時エラーチェックは実験的な実装です．
\|array|を用いて作成した静的な配列インスタンスには使用できますが，
\|malloc|を用いて作成した動的な配列インスタンスには使用できません．

\begin{flushleft}
{\bf 形式 : }~~~\|rtc-c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]|\\
({\bf 注意}：オプションは書式の順番で指定する必要があります．)
\end{flushleft}

引数の意味は{\cmmc}コマンドと同様です．

\section{{\icmmc}コマンド}
\label{command:icmmc}

中間言語を出力する{\cmm}コンパイラです．
{\bf 通常は{\cmi}から起動されユーザが直接使用することはありません．}

中間言語の仕様は，\pageref{app:vm}ページに掲載してあります．
コンパイラの仕組みを学習したいときに利用します．
{\icmmc}コマンドの書式は次の通りです．

\begin{flushleft}
{\bf 形式 : }~~~\|ic-c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]|
\end{flushleft}

引数の意味は{\cmmc}コマンドと同様です．

\section{{\vcmmc}コマンド}
\label{command:vcmmc}

仮想スタックマシンのニーモニックを出力する{\cmm}コンパイラです．
{\bf 通常は{\cmv}から起動されユーザが直接使用することはありません．}

仮想スタックマシンのニーモニックは，
コンパイラ内部で用いている中間言語（\pageref{app:vm}ページ参照）と，
ほぼ一対一に対応します．
中間言語や仮想スタックマシンを学習したいときに利用します．
{\vcmmc}コマンドの書式は次の通りです．

\begin{flushleft}
{\bf 形式 : }~~~\|vm-c-- [-h] [-v] [-O0] [-O] [-O1] [-K] [<source file>]|
\end{flushleft}

引数の意味は{\cmmc}コマンドと同様です．
%次の実行例は変換結果を画面に表示しています．
%
%\begin{mylist}
%\begin{verbatim}
%$ cc -E -std=c99 -nostdinc -I/usr/local/cmmInclude \
% - < hello.cmm | vm-c--
%_stdin
%        WS      1
%_stdout
%        WS      1
%_stderr
%        WS      1
%.L1
%        STRING  "hello,world\n"
%_main
%        ENTRY   0
%        LDC     .L1
%        ARG
%        CALLF   1,_printf
%        POP
%        LDC     0
%        MREG
%        RET
%\end{verbatim}
%\end{mylist}

